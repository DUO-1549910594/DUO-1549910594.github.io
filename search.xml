<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2023/05/27/%E8%99%9A%E7%9F%AD%E8%99%9A%E6%96%AD%E5%8E%9F%E7%90%86/"/>
      <url>2023/05/27/%E8%99%9A%E7%9F%AD%E8%99%9A%E6%96%AD%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="虚短虚断原理"><a href="#虚短虚断原理" class="headerlink" title="虚短虚断原理"></a>虚短虚断原理</h1><p>对于虚短虚断原理，其实运放本身是不能理解的，这只是我们分析电路时根据运放特性而总结的一种电路分析的方法。</p><h2 id="虚短的来源"><a href="#虚短的来源" class="headerlink" title="虚短的来源"></a>虚短的来源</h2><p>前提：运放在深度负反馈，且输出没有饱和的情况下<br>运放遵循以下原则：</p><ul><li>（1）输入端发生变化后，运放需要等待一定时间才能对输出实施改变。即输出动作会滞后输入一定的时间，此时间被称为延迟时间；</li><li>（2）它将两个输入端电位实施减法，得到$$u_{id} = u_{+} - u_{-}$$,在内部实施乘法运算，得到期望输出值$$u_{id}A_{uo}$$;</li><li>（3）未达到期望输出值，运放以压摆率向目标前进；</li><li>（4）如果运放的输出端达到电压但仍未达到期望输出值，则会停留在最大输出电压处。</li><li>（5）若已经达到期望输出值，则运放的输出端就稳定不变了。</li></ul><p>这里以2倍同向比例放大进行解释：<br>假设开环电压增益为100000，延迟时间为1us，压摆率为SR = 1V/us，运放供电电压为±5V，最大输出电压为±4.5V。</p><p><img src="/.io//20230527124455.png"></p><p><img src="/.io//20230527124550.png"></p><p>变化过程如下：</p><ul><li>（1）输入信号（绿色线）在1us处从0V变为2V，形成阶跃输入u1；1us~2us之间，运放的输出端电压（红色线）uo没有变化（1us延迟时间）</li><li>（2）2us处，运放开始工作，此时正负输入端差值为2v，故目标输出电压为200000V，故此时以压摆率向目标输出电压前进；</li><li>（3）当输出电压增大时，负输入端电压也在增大，此时正负输入端差值减小，期望输出电压也在下降，但仍然很大，远大于电源电压5V；</li><li>（4）正输入端一直为2V，负输入端不断接近2V，当<br>$$(u_{+} - u_{-})<em>A_{uo} = u_{o}$$<br>即：<br>$$(2V - 0.5u_{o})<em>100000 = u_{o}$$<br>可以计算出此时输出电压为3.9999200016V时，运放发现自己达到了期望输出值，此时不在前进保持稳定，**这时：虚短成立</em></em> 。</li></ul><h2 id="虚断的来源"><a href="#虚断的来源" class="headerlink" title="虚断的来源"></a>虚断的来源</h2><p>虚断其实是由于运放的输入阻抗较大，大多数情况下是成立的，只有当外部电阻接近运放输入电阻时，或者运放输入管脚外部流过的电流，接近或者超过运放输入端的微小电压时，虚断才失效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>滤波器</title>
      <link href="2022/04/17/%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
      <url>2022/04/17/%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="运放组成的滤波器"><a href="#运放组成的滤波器" class="headerlink" title="运放组成的滤波器"></a>运放组成的滤波器</h1><h2 id="一、四元件低通滤波器"><a href="#一、四元件低通滤波器" class="headerlink" title="一、四元件低通滤波器"></a>一、四元件低通滤波器</h2><h3 id="1-SK低通滤波器"><a href="#1-SK低通滤波器" class="headerlink" title="1.SK低通滤波器"></a>1.SK低通滤波器</h3><p>SK电路原型：</p><p><img src="images/20220417202933.png"></p><p>低通滤波器Z1,Z2为电阻，Z3,Z4为电容，这里就是单纯的低通滤波，电路的增益为1。故我们需要考虑的就只有元件参数的选择。</p><p>对于特定的电路要求，比如已知截止频率和品质因数（可自己设定），来确定阻值和容值。<br>截止频率即当输出信号的幅值与输入信号的幅值的比值为根号二分之一时（半功率点），品质因数决定衰减速度。具体推导过程省略，这里直接给出结论。</p><p><img src="images/20220417203728.png" alt="传参函数"></p><p>截止频率与品质因数与电路元件的关系：<br><img src="images/20220417204019.png"></p><p>电阻值的选择：<br><img src="images/20220417203925.png"></p><p>电容的选择一般可以根据经验值确定，这里列出一个表格：<br><img src="images/20220417204912.png"><br>这个表格对于低通或者高通都是适用的。这里需要注意电容的选择必须要让式子有意义。<br>若两个电阻和电容都取相等的值，则变成了等阻容低通滤波器（贝塞尔滤波器，Q=0.5）；若使Z4=2*Z3（电容二倍关系），电阻阻值相等，则为易用性巴特沃斯低通滤波器（Q=0.707).</p><h3 id="1-SK高通滤波器"><a href="#1-SK高通滤波器" class="headerlink" title="1.SK高通滤波器"></a>1.SK高通滤波器</h3><p>SK高通滤波器的结构和低通滤波器类似，只是这里电阻和电容的位置互换；</p><p>如图：</p><p><img src="images/20220424194649.png"></p><p>同样的，根据电路的要求如品质因数和截止频率可以确定电阻和电容的阻值。截止频率和品质因数与电阻电容的关系如下：</p><p><img src="images/20220424194813.png"></p><p>这里只介绍简易型SK高通滤波器，四元件巴特沃斯型，电阻为二倍关系，电容为查表值：</p><p><img src="images/20220424195019.png"></p><p>结果如下：</p><p><img src="images/20220424195212.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算放大器</title>
      <link href="2022/03/04/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/"/>
      <url>2022/03/04/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h1><h2 id="1-噪声"><a href="#1-噪声" class="headerlink" title="1.噪声"></a>1.噪声</h2><p>运放的噪声来源有很多，如：热噪声，散粒噪声等等；但是最为常见的噪声根源有两类：一类是1/f噪声，其电能力密度曲线随着频率的上升而下降；一类产生白噪声，或者叫平坦噪声，其电能力密度曲线是一条直线，与频率无关。</p><p>两者的电能力密度图如图所示：<br><img src="images/20220304152455.png" alt="电能力密度图"><br>在一定的频率范围内，我们都可以通过上图计算出两类噪声的有效值。</p><p>两种噪声有效值的计算方法，其重点在于得到C和K两个值。<br><img src="images/20220304152728.png"><br>可以根据厂家给的数据手册来查找C和K的值，噪声频率较小的时候1/f作用较为明显；噪声频率较大的时候白噪声作用较为明显。</p><p><strong>K的确定：</strong>（1）读图法，读厂家给的数据手册；（2）数据法，多数数据手册会在指标表里以en为标示给出；</p><p><strong>C的确定：</strong>（1）曲线涵盖1Hz，通过读图得到1Hz时的噪声值，然后有和噪声值和白噪声值可以算出1/f的C的值；（2）曲线不涵盖1Hz：<img src="images/20220304153558.png"><br>（3）通过转角频率，有些厂家会给出转角频率，转角频率就是处于这个频率下，1/f噪声电能力密度等于白噪声电能力密度等于K，再根据1/f噪声的定义可以得出C。</p><p><strong>噪声有效值与峰峰值的关系:</strong> 峰峰值等于有效值的6.6倍。</p><p><strong>实际运放噪声的计算：</strong> 实际运放的噪声来源有电压源噪声，电流源噪声，电阻热噪声。<br>方法如下：<br>（1） 获得等效带宽 fb，确定 fa，可能是 0.1Hz 或者 0.01Hz。 </p><p>（2） 根据前述方法，结合带宽计算运放等效输入噪声电压 UN_I；</p><p>（3） 结合带宽计算各个电阻的热噪声 UN_Ri；（式 2-18） </p><p>（4） 查找数据手册，获得等效输入电流噪声的关键参数 CI 和 KI，结合带宽计算等效输入电流噪声 IN_1 和 IN_2； </p><p>（5） 以上述 3 类共 7 个源，分别计算在输出端的结果 UOm，m 代表不同的源。其中上标 O 代表该噪声源在运放输出端呈现的噪声电压有效值。</p><p> (6) 对各个 UOm实施平方式叠加，即为最终输出噪声。</p><p><strong>电阻的热噪声计算：</strong> 电阻噪声计算较为复杂，包含热噪声、接触噪声和散粒噪声等。在特殊电路比如音响放大电路中，要考虑很多问题来减少噪声，比如降低均值电流、增大电阻体积等。但是在运放电路中，一般仅考虑电阻的热噪声。<br><img src="images/20220304161218.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运算放大器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>晶体管基础</title>
      <link href="2022/01/18/%E6%99%B6%E4%BD%93%E7%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>2022/01/18/%E6%99%B6%E4%BD%93%E7%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="信号失真分析"><a href="#信号失真分析" class="headerlink" title="信号失真分析"></a>信号失真分析</h1><h2 id="1-大信号失真"><a href="#1-大信号失真" class="headerlink" title="1.大信号失真"></a>1.大信号失真</h2><p>因信号的赋值过大，使得输入信号在正峰值或者负峰值的时候，会使得晶体管进入饱和区或者进入截止区；另一个原因是由于信号幅值过大，使得输入伏安特性曲线中的非线性部分完全显现出来，造成非线性失真。</p><h2 id="2-饱和失真和截止失真"><a href="#2-饱和失真和截止失真" class="headerlink" title="2.饱和失真和截止失真"></a>2.饱和失真和截止失真</h2><p>如图：</p><p><img src="images/20220118095210.png"></p><p>当输出信号幅值超过电压时，使得集电极没有电流（基极也没有电流），发生截至失真；而当输出信号幅值为负值时（Uceq&lt;0.3v），发生饱和失真。</p><p><strong>失真电压裕度</strong>：我们把静态集电极-射极电压到截止失真的电压差值称为截至失真电压裕度；到饱和失真的电压差值称为饱和电压裕度，两者的最小值称为失真电压裕度。<strong>注意</strong>：不一定是饱和电压裕度一定小于截止电压裕度，这和静态工作点有关，所以要根据具体电路来分析，看是先发生什么类型的失真。</p><p><img src="images/20220118100138.png"></p><p>可以根据上图加深对截止失真和饱和失真的理解。</p><h2 id="3-T型偏置电路"><a href="#3-T型偏置电路" class="headerlink" title="3.T型偏置电路"></a>3.T型偏置电路</h2><p><img src="images/20220226192918.png" alt="T型偏置电路"></p><p>分析T偏置电路：静态通路分析：</p><p><img src="images/20220226193544.png"></p><p>动态通路分析：</p><p><img src="images/20220226193656.png"></p><p>可知：与两电阻分压电路相比，T型偏置电路更加灵活；当要求基极电压较小切输入电阻较大的时候，电阻分压电路则需要更大的电阻，而T型偏置电路则是两电阻并联加上一个电阻值，同时基极电压任然是两电阻分压值，输入电阻与基极电压相互独立；同时图中的电容C4（去耦电容），可以减少电源电压的噪声对输入端的影响。</p><h2 id="4-MOSFET"><a href="#4-MOSFET" class="headerlink" title="4.MOSFET"></a>4.MOSFET</h2><p><img src="images/20220226194451.png"><br>由于MOSFET的绝缘栅结构，没有输入电流，所以只有转移伏安特性曲线和输出伏安特性曲线，所以求解电路状态主要在于Ugs，Id；</p><p><img src="images/20220226194742.png"></p><p>一般阈值电压（开启电压），和K值一般都会给。<br>工作状态分类：</p><p><img src="images/20220226195826.png"></p><h2 id="5-电流镜基本原理"><a href="#5-电流镜基本原理" class="headerlink" title="5.电流镜基本原理"></a>5.电流镜基本原理</h2><p>电流镜的基本原理其核心是两个基极连在一起，两个发射极连在一起，以迫使两者具有相同的Ube，以使其Ib相等，进而保证Ic相等。</p><p><img src="images/20220226202328.png"></p><p>通过对晶体管的性质可得：</p><p><img src="images/20220226202650.png"></p><p>但是实际的电流镜的输出并不是按照比例预期的，和理论计算存在较大的误差，原因在于：厄利电压。</p><p><img src="images/20220226203701.png"></p><p><img src="images/20220226203824.png"></p><p>输出端的初始电压和Uce对集电极的电流（输出电流）都有影响。对于一个确定的伏安特性曲线，可以根据厄利电压和集电极射极饱和电压以及理想输出集电极电流，来确定实际的输出电流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 晶体管基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT</title>
      <link href="2021/12/09/GIT/"/>
      <url>2021/12/09/GIT/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><h2 id="一、创建版本库"><a href="#一、创建版本库" class="headerlink" title="一、创建版本库"></a>一、创建版本库</h2><p>版本库又名仓库，即：repository，仓库里面的所有文件都可以被git管理，文件的删、修改，git都可以跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>创建一个版本库：</p><p>首先选择一个合适的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>将文件添加到版本库里面：</p><p>将需要添加的文件（比如：readme.txt）放置在learngit目录下面，然后输入指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add 文件</span><br><span class="line">$ git commit -m <span class="string">&quot;对文件的描述&quot;</span></span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>x file changed</code>：x个文件被改动（我们新添加的readme.txt文件）；<code>x insertions</code>：插入了x行内容（readme.txt有x行内容）。</p><p>add可以多次添加很多文件（暂存区），commit可以一次提交很多文件（工作区）</p><h2 id="二、版本回退"><a href="#二、版本回退" class="headerlink" title="二、版本回退"></a>二、版本回退</h2><p>在git中查看版本的指令为：<code>git log</code></p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>一大串数字是commit id ，即：版本号。版本号是SHA1计算出来的一个非常大的数字，故每个人的版本号不一样。</p><p>回退至上一个版本使用指令：<code>$ git reset --hard HRAD^ </code></p><p>回退至上一个版本之后无法回到更改先的版本，如果要返回的话，需要知道那个版本的版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>版本号不需要写全，只写前面部分即可。</p><p>git内部有指向当前版本的指针，回退版本时，git将指针HAED改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>git中的指令<code>git reflog</code>是用来记录你的每一个历史指令的，可以通过它来查找版本号</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><h2 id="三、工作区和暂存区"><a href="#三、工作区和暂存区" class="headerlink" title="三、工作区和暂存区"></a>三、工作区和暂存区</h2><p>工作区（Working Directory）:就是电脑里能看到的目录，比如learngit文件夹就是一个工作区；</p><p>版本库（Repository）:工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h2 id="四、撤销修改与删除文件"><a href="#四、撤销修改与删除文件" class="headerlink" title="四、撤销修改与删除文件"></a>四、撤销修改与删除文件</h2><p>git管理的其实是修改而不是文件，举个例子：假如你对readme.txt第一次修改后add并且commit，然后再进行第二次修改，然后直接commit，用指令：<code>git status</code>发现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>第二次修改没有被提交。</p><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>可以用指令<code>git diff HEAD -- readme.txt</code>查看工作区和版本库里面最新版本的区别。</p><h3 id="1-git-checkout-–-file撤销修改："><a href="#1-git-checkout-–-file撤销修改：" class="headerlink" title="1.git checkout – file撤销修改："></a>1.git checkout – file撤销修改：</h3><p>分两种情况，第一种是文件自修改后还没有被放到暂存区（还没add），现在，撤销修改就回到和版本库（即修改前）一模一样的状态；第二种情况是文件已经添加到暂存区后，又作了修改（add但是没有commit），现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>注意：git checkout – file 中的–很重要，没有 – 就变成了“切换到另一个分支”的命令。</p><p>如果你修改错误的地方add并commit了，可以用<code>git reset</code>，将修改撤回后重新放回工作区，再<code>git checkout -- file</code>即可。</p><h3 id="2-删除文件："><a href="#2-删除文件：" class="headerlink" title="2.删除文件："></a>2.删除文件：</h3><p>对于不需要的文件，可以使用指令<code>rm</code>删除</p><p><code>rm file</code>只能删除工作区的文件，但是不能更新版本库，使用git status查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>这时需要在版本库中删除文件并且commit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>如果是误删了，因为版本库里面还有该文件，所以使用指令<code>git checkout -- file</code>即可恢复。</p><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h2 id="五、远程仓库"><a href="#五、远程仓库" class="headerlink" title="五、远程仓库"></a>五、远程仓库</h2><h3 id="1-添加远程库"><a href="#1-添加远程库" class="headerlink" title="1.添加远程库"></a>1.添加远程库</h3><p>我们在本地写的代码可以使用Github（Gayhub）进行托管，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来写作，在进行多人项目开发的时候十分方便。<br>1.首先，登陆GitHub，然后，在右上角找到“Creat a new repo”，创建一个新的仓库；<br>2.在Repository name填入<code>learngit</code>（本地仓库名称），其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库；<br>在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。<br>这时，我们在本地仓库下运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add 仓库名称</span><br><span class="line">git@github.com:GitHub账户名/learngit.git</span><br></pre></td></tr></table></figure><p>下一步就可以把本地库的所有内容推送到远程库上：<br>使用指令：<code>git push -u 仓库名 master</code><br>将本地库的内容推送至远程仓库使用<code>git push</code>，实际上是把当前分支master推送到远程。第一次推送的时候我们使用了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>下一次在此推送只需要从本地直接push即可：<code>git push 仓库名 master</code><br>注意：第一次使用push或者clone指令连接到GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。这个警告只会出现一次，后面的操作就不会有任何警告了。如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。</p><h3 id="2-从远程库克隆"><a href="#2-从远程库克隆" class="headerlink" title="2.从远程库克隆"></a>2.从远程库克隆</h3><p>想要将GitHub上面的仓库下载到本地，只需要使用指令<code>git clone</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:账户名/仓库名.git</span><br></pre></td></tr></table></figure><p>这个地址可以直接从要下载的仓库上下载。GitHub给出的地址不止一个，还可以用<a href="https://github.com/%E8%B4%A6%E6%88%B7%E5%90%8D/gitskills.git%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82%E5%AE%9E%E9%99%85%E4%B8%8A%EF%BC%8CGit%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84git://%E4%BD%BF%E7%94%A8ssh%EF%BC%8C%E4%BD%86%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8https%E7%AD%89%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%E3%80%82">https://github.com/账户名/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p><p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p><h2 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h2><h3 id="1-创建与合并分支"><a href="#1-创建与合并分支" class="headerlink" title="1.创建与合并分支"></a>1.创建与合并分支</h3><p>每次提交，git都把他们串成一条时间线，这条时间线就是一个分支，这个分支叫主分支，即：master分支。HEAD不是指向提交，而是指向master，master指向提交，所以head指向当前分支。<br>一开始的时候，master分支是一条线，git用master指向最新提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p><p><img src="images/20211209201643.png" alt="20211209201643"><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p><p><img src="images/20211209202009.png" alt="20211209202009"></p><p>再对工作区的修改和提交就是针对dev分支了，每新一次提交，dev指针向前移动一步，而master指针不变：</p><p><img src="images/20211209202243.png" alt="20211209202243"></p><p>若分支dev上面的工作完成了，只需要将dev合并到master上面即可：将mater指向dev当前提交即可。（同时删除dev分支，即dev指针）：</p><p><img src="images/20211209202421.png" alt="20211209202421"></p><p>创建dev分支，然后切换到dev分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure><p>然后，用git branch命令查看当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>git branch命令会列出所有分支，当前分支前面会标一个*号。然后我们就可以在dev分支上正常提交。<br>dev分支的工作完成，我们就可以切换回master分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p>这时是无法查看刚刚的更改的，因为改动在dev分支。<br>现在，我们把dev分支的工作成果合并到master分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。<br>合并完成后，就可以删除dev分支了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>删除后，查看branch，就只剩下master分支了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-ADC实验</title>
      <link href="2021/11/20/STM32-ADC%E5%AE%9E%E9%AA%8C/"/>
      <url>2021/11/20/STM32-ADC%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="STM32-ADC实验"><a href="#STM32-ADC实验" class="headerlink" title="STM32-ADC实验"></a>STM32-ADC实验</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="1-ADC初始化函数ADC-Init"><a href="#1-ADC初始化函数ADC-Init" class="headerlink" title="1.ADC初始化函数ADC_Init"></a>1.ADC初始化函数ADC_Init</h3><p><code>void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);</code></p><p>第二个结构体指针的介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> ADC_Mode;                      <span class="comment">/*!&lt; Configures the ADC to operate in independent or</span></span><br><span class="line"><span class="comment">                                               dual mode. </span></span><br><span class="line"><span class="comment">                                               This parameter can be a value of @ref ADC_mode */</span></span><br><span class="line"></span><br><span class="line">  FunctionalState ADC_ScanConvMode;       <span class="comment">/*!&lt; Specifies whether the conversion is performed in</span></span><br><span class="line"><span class="comment">                                               Scan (multichannels) or Single (one channel) mode.</span></span><br><span class="line"><span class="comment">                                               This parameter can be set to ENABLE or DISABLE */</span></span><br><span class="line"></span><br><span class="line">  FunctionalState ADC_ContinuousConvMode; <span class="comment">/*!&lt; Specifies whether the conversion is performed in</span></span><br><span class="line"><span class="comment">                                               Continuous or Single mode.</span></span><br><span class="line"><span class="comment">                                               This parameter can be set to ENABLE or DISABLE. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> ADC_ExternalTrigConv;          <span class="comment">/*!&lt; Defines the external trigger used to start the analog</span></span><br><span class="line"><span class="comment">                                               to digital conversion of regular channels. This parameter</span></span><br><span class="line"><span class="comment">                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> ADC_DataAlign;                 <span class="comment">/*!&lt; Specifies whether the ADC data alignment is left or right.</span></span><br><span class="line"><span class="comment">                                               This parameter can be a value of @ref ADC_data_align */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint8_t</span> ADC_NbrOfChannel;               <span class="comment">/*!&lt; Specifies the number of ADC channels that will be converted</span></span><br><span class="line"><span class="comment">                                               using the sequencer for regular channel group.</span></span><br><span class="line"><span class="comment">                                               This parameter must range from 1 to 16. */</span></span><br><span class="line">&#125;ADC_InitTypeDef;</span><br></pre></td></tr></table></figure><p><img src="/.io//images%5CADC_Init.png" alt="ADC_Init"></p><h3 id="2-ADC使能函数ADC-Cmd"><a href="#2-ADC使能函数ADC-Cmd" class="headerlink" title="2.ADC使能函数ADC_Cmd();"></a>2.ADC使能函数ADC_Cmd();</h3><p><code>void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);</code></p><h3 id="3-ADC使能软件转换函数ADC-SoftwareStartConvCmd"><a href="#3-ADC使能软件转换函数ADC-SoftwareStartConvCmd" class="headerlink" title="3.ADC使能软件转换函数ADC_SoftwareStartConvCmd"></a>3.ADC使能软件转换函数ADC_SoftwareStartConvCmd</h3><p><code>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);</code></p><h3 id="4-ADC规则通道配置函数ADC-RegularChannelConfig"><a href="#4-ADC规则通道配置函数ADC-RegularChannelConfig" class="headerlink" title="4.ADC规则通道配置函数ADC_RegularChannelConfig"></a>4.ADC规则通道配置函数ADC_RegularChannelConfig</h3><p><code>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);</code></p><h3 id="5-ADC获取转换结果函数ADC-GetConversionValue"><a href="#5-ADC获取转换结果函数ADC-GetConversionValue" class="headerlink" title="5.ADC获取转换结果函数ADC_GetConversionValue"></a>5.ADC获取转换结果函数ADC_GetConversionValue</h3><p><code>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32-ADC实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC通信</title>
      <link href="2021/10/06/IIC%E9%80%9A%E4%BF%A1/"/>
      <url>2021/10/06/IIC%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h1><h2 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h2><ul><li>空闲信号</li><li>开始信号</li><li>停止信号</li><li>应答信号</li><li>数据的有效性</li><li>数据传输</li></ul><p><strong>注意：STM32有关IIC相关的函数在文件myiic.h和myiic.c里面</strong></p><h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化IIC</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE );<span class="comment">//使能GPIOB时钟</span></span><br><span class="line">   </span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_6|GPIO_Pin_7); <span class="comment">//PB6,PB7 输出高</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生IIC起始信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SDA_OUT();     <span class="comment">//sda线输出</span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line"> IIC_SDA=<span class="number">0</span>;<span class="comment">//START:when CLK is high,DATA change form high to low </span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;<span class="comment">//钳住I2C总线，准备发送或接收数据 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//产生IIC停止信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SDA_OUT();<span class="comment">//sda线输出</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;<span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line"> delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;<span class="comment">//发送I2C总线结束信号</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等待应答信号到来</span></span><br><span class="line"><span class="comment">//返回值：1，接收应答失败</span></span><br><span class="line"><span class="comment">//        0，接收应答成功</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_Wait_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 ucErrTime=<span class="number">0</span>;</span><br><span class="line">SDA_IN();      <span class="comment">//SDA设置为输入  </span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;delay_us(<span class="number">1</span>);   </span><br><span class="line">IIC_SCL=<span class="number">1</span>;delay_us(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span>(READ_SDA)</span><br><span class="line">&#123;</span><br><span class="line">ucErrTime++;</span><br><span class="line"><span class="keyword">if</span>(ucErrTime&gt;<span class="number">250</span>)</span><br><span class="line">&#123;</span><br><span class="line">IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;<span class="comment">//时钟输出0    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//产生ACK应答</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();</span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不产生ACK应答    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_NAck</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();</span><br><span class="line">IIC_SDA=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;      </span><br><span class="line"><span class="comment">//IIC发送一个字节</span></span><br><span class="line"><span class="comment">//返回从机有无应答</span></span><br><span class="line"><span class="comment">//1，有应答</span></span><br><span class="line"><span class="comment">//0，无应答  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span></span><br><span class="line"><span class="function"></span>&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">SDA_OUT();     </span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//拉低时钟开始数据传输</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        IIC_SDA=(txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;</span><br><span class="line">        txd&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">delay_us(<span class="number">2</span>);   <span class="comment">//对TEA5767这三个延时都是必须的</span></span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   </span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_Read_Byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">SDA_IN();<span class="comment">//SDA设置为输入</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ )</span><br><span class="line">&#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>; </span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(READ_SDA)receive++;   </span><br><span class="line">delay_us(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        IIC_NAck();<span class="comment">//发送nACK</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack(); <span class="comment">//发送ACK   </span></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码其中的相关标识符在myiic.h里面都已经定义了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IO方向设置</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDA_IN()  &#123;GPIOB-&gt;CRL&amp;=0X0FFFFFFF;GPIOB-&gt;CRL|=(u32)8&lt;&lt;28;&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDA_OUT() &#123;GPIOB-&gt;CRL&amp;=0X0FFFFFFF;GPIOB-&gt;CRL|=(u32)3&lt;&lt;28;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IO操作函数 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SCL    PBout(6) <span class="comment">//SCL</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA    PBout(7) <span class="comment">//SDA </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_SDA   PBin(7)  <span class="comment">//输入SDA </span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> IIC通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32串口通信</title>
      <link href="2021/10/05/STM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>2021/10/05/STM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="STM32串口通信"><a href="#STM32串口通信" class="headerlink" title="STM32串口通信"></a>STM32串口通信</h1><h2 id="一-STM32串口常用的寄存器和库函数"><a href="#一-STM32串口常用的寄存器和库函数" class="headerlink" title="一.STM32串口常用的寄存器和库函数"></a>一.STM32串口常用的寄存器和库函数</h2><h3 id="1-常用的寄存器"><a href="#1-常用的寄存器" class="headerlink" title="1.常用的寄存器"></a>1.常用的寄存器</h3><ul><li>USART_SR状态寄存：串口通信的状态数据</li><li>USART_DR数据寄存器：读写数据</li><li>USART_BRR波特率寄存器：配置波特率</li><li>USART_CR1/2/3控制寄存器：发送接收使能以及一些相关的中断使能</li></ul><p><strong>波特率计算方法：</strong>Tx/Rx波特率 = f/(16*USARTDIV) {假设串口1要设置为115200的波特率，而PCLK2的时钟为72M，这样：波特率 = 72000000/(115200 x 16) = 39.0625}</p><p><strong>如何配置整数和小数部分：</strong>整数部分DIV_Mantissa = 39 = 0x27(直接设置为16进制)</p><p>​                                              小数部分DIV_Mantissa = 16*0.0625 = 1 = 0x01;(乘以16再转换)</p><h3 id="2-串口常用的库函数"><a href="#2-串口常用的库函数" class="headerlink" title="2.串口常用的库函数"></a>2.串口常用的库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Init</span><span class="params">()</span></span>;<span class="comment">//串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Cmd</span><span class="params">()</span></span>;<span class="comment">//使能串口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ITConfig</span><span class="params">()</span></span>;<span class="comment">//使能相关中断</span></span><br><span class="line"></span><br><span class="line">操作DR寄存器</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendData</span><span class="params">()</span></span>;<span class="comment">//发送数据到串口，DR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ReceiveData</span><span class="params">()</span></span>;<span class="comment">//接受数据，从DR读取接受到的数据</span></span><br><span class="line"></span><br><span class="line">对SR寄存器进行读</span><br><span class="line"><span class="function">FlagStatus <span class="title">USART_GetFlagStatus</span><span class="params">()</span></span>;<span class="comment">//获取状态标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearFlag</span><span class="params">()</span></span>;<span class="comment">//清除状态标志位</span></span><br><span class="line"><span class="function">ITStatus <span class="title">USART_GetITStatus</span><span class="params">()</span></span>;<span class="comment">//获取中断标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">()</span></span>;<span class="comment">//清除中断，状态标志位</span></span><br></pre></td></tr></table></figure><h3 id="3-串口配置的一般步骤"><a href="#3-串口配置的一般步骤" class="headerlink" title="3.串口配置的一般步骤"></a>3.串口配置的一般步骤</h3><ul><li><p>串口时钟使能，GPIO时钟使能：RCC_APB2PeriClockCmd();</p></li><li><p>串口复位：USART_DeInit();这一步不是必须的；</p></li><li><p>GPIO端口模式设置（设置为复用）：GPIO_Init();模式设置(查表)</p></li><li><p>串口参数初始化：USART_Init();</p></li><li><p>开启中断并且初始化NVIC（需要中断的话）</p><p>NVIC_Init();</p><p>USART_ITConfig();</p></li><li><p>使能串口：USART_Cmd();</p></li><li><p>编写中断处理函数：USARTx_IRQHandler();</p></li><li><p>串口数据收发：</p><p>void USART_SendData();</p><p>uint16_t USART_ReceiveData();</p></li><li><p>串口传输状态获取：</p><p>FlagStatus USART_GetFlagStatus();</p><p>void USART_ClearITPendingBit();//清除中断，状态标志位</p></li></ul><h3 id="4-具体代码"><a href="#4-具体代码" class="headerlink" title="4.具体代码"></a>4.具体代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 bound)</span></span>&#123;</span><br><span class="line">  <span class="comment">//GPIO端口设置</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">USART_InitTypeDef USART_InitStructure;</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"> </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);<span class="comment">//使能USART1，GPIOA时钟</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//USART1_TX   GPIOA.9</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; <span class="comment">//PA.9</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOA.9</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">//USART1_RX  GPIOA.10初始化</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<span class="comment">//PA10</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<span class="comment">//浮空输入</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOA.10  </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Usart1 NVIC 配置（）涉及中断才写</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">3</span> ;<span class="comment">//抢占优先级3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;<span class="comment">//子优先级3</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//IRQ通道使能</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//根据指定的参数初始化VIC寄存器</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//USART 初始化设置</span></span><br><span class="line"></span><br><span class="line">USART_InitStructure.USART_BaudRate = bound;<span class="comment">//串口波特率</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//字长为8位数据格式</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//一个停止位</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//无奇偶校验位</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//收发模式</span></span><br><span class="line"></span><br><span class="line">  USART_Init(USART1, &amp;USART_InitStructure); <span class="comment">//初始化串口1</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<span class="comment">//开启串口接受中断</span></span><br><span class="line">  USART_Cmd(USART1, ENABLE);                    <span class="comment">//使能串口1 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>                <span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 Res;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE))  <span class="comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span></span><br><span class="line">&#123;</span><br><span class="line">Res =USART_ReceiveData(USART1);<span class="comment">//读取接收到的数据</span></span><br><span class="line">USART_SendData(USART1,Res);</span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line">uart_init(<span class="number">115200</span>); <span class="comment">//串口初始化为115200</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STM32串口通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-左值和右值</title>
      <link href="2021/09/20/C%E8%AF%AD%E8%A8%80-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
      <url>2021/09/20/C%E8%AF%AD%E8%A8%80-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="C语言-左值和右值"><a href="#C语言-左值和右值" class="headerlink" title="C语言-左值和右值"></a>C语言-左值和右值</h1><p><strong>左值：</strong>可以出现在赋值符号左边的东西；</p><p><strong>右值：</strong>可以出现在赋值符号右边的东西。</p><p>注意：左值并不是只能是变量，也可以是表达式，如：<code>a[b+10] = 0;</code>是否可以作为左值，主要在于赋值符号左边是否标识了一特定的位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言-左值和右值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-位的操纵</title>
      <link href="2021/09/05/C%E8%AF%AD%E8%A8%80-%E4%BD%8D%E7%9A%84%E6%93%8D%E7%BA%B5/"/>
      <url>2021/09/05/C%E8%AF%AD%E8%A8%80-%E4%BD%8D%E7%9A%84%E6%93%8D%E7%BA%B5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="C语言-位的操纵"><a href="#C语言-位的操纵" class="headerlink" title="C语言-位的操纵"></a>C语言-位的操纵</h1><p>表达式假定变量bit_number为一整型值，它的范围是从0至整型值的位数减1，并且整型值的位从右向左计数；</p><p>第一个例子：把指定的位设置为1：</p><p><code>vuale = vuale | 1 &lt;&lt; bit_number;</code></p><p>写一个例子：把指定的位清0：</p><p><code>vuale = vuale &amp; ~(1 &lt;&lt; bit_number);</code></p><p>对指定的位进行测试，如果该位已经被设置为1，则表达式的结果为非零值：</p><p><code>vuale &amp; 1 &lt;&lt; bit_number;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言-位的操纵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-static关键字</title>
      <link href="2021/08/25/C%E8%AF%AD%E8%A8%80-static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/08/25/C%E8%AF%AD%E8%A8%80-static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="C语言-static关键字"><a href="#C语言-static关键字" class="headerlink" title="C语言-static关键字"></a>C语言-static关键字</h1><ul><li>当它用于函数定义或者用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性，从external改为internal，但标识符发存储类型和作用域不受影响，用这种方式声明的函数或变量只能在声明它们的源文件中访问；</li><li>当它用于代码块内部的变量声明时，static关键字用于修改变量的存储类型，从自动变量修改为静态变量，但是变量的链接属性和作用域不受影响。用这种方式声明的变量在程序执行之前创建，并在程序的整个执行期间一直存在，而不是每次在代码块开始执行时创建，在代码块执行完毕后销毁。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C语言-static关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-typedef</title>
      <link href="2021/08/24/C%E8%AF%AD%E8%A8%80-typedef/"/>
      <url>2021/08/24/C%E8%AF%AD%E8%A8%80-typedef/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="C语言-typedef"><a href="#C语言-typedef" class="headerlink" title="C语言-typedef"></a>C语言-typedef</h1><p>typedef允许为各种数据类型定义新名字，其声明写法和普通的声明基本相同，只要把typedef这个关键字放在声明的前面即可。</p><p>例如：<code>typedef char *ptr_to_char</code>这个声明将ptr_to_char声明为一个指向字符的指针</p><p><code>ptr_to_char a;</code>声明a是一个指向字符的指针，使用typedef声明类型可以减少使声明变得又臭又长的危险。</p><p>注意：创建新的类型名应该用typedef而不是#define，后者无法正确地处理指针类型，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d_ptr_to_char char*</span></span><br><span class="line">d_ptr_to_char a,b;</span><br></pre></td></tr></table></figure><p>这里正确地声明了a，但是b却是被声明为一个字符。在定义更为复杂的类型名字时，如函数指针或指向数组的指针，使用typedef更为合适。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言-typedef </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 IO口简介</title>
      <link href="2021/08/04/STM32%20IO%E5%8F%A3/"/>
      <url>2021/08/04/STM32%20IO%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="STM32-IO口简介"><a href="#STM32-IO口简介" class="headerlink" title="STM32 IO口简介"></a>STM32 IO口简介</h1><h2 id="1-STM32-IO口的配置"><a href="#1-STM32-IO口的配置" class="headerlink" title="1.STM32 IO口的配置"></a>1.STM32 IO口的配置</h2><p>​        首先 STM32 的 IO 口可以自由编程（但 IO 口寄存器CRL，CRH必须要按 32 位字被访问），由软件配置成如下 8 种模式：输入浮空 、输入上拉、输入下拉、模拟输入、开漏输出、推挽输出、推挽式复用功能、开漏复用功能。（四个输入，两个输出，两个复用）。</p><p>STM32 的 IO 口位配置表如表 1所示：</p><p>![IO 口位配置表](images\STM32 IO口位配置表.png)</p><p>STM32 输出模式配置如表 2所示：</p><p>![STM32 输出模式](images\STM32 输出模式.png)</p><p>具体的端口低配置寄存器 CRL 各位描述：</p><p><img src="/.io//images%5C%E7%AB%AF%E5%8F%A3%E4%BD%8E%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8.png"></p><p>​        一组IO口有十六个端口（0~F），寄存器CRL配置每组IO口的低八个IO口，寄存器CRH配置每组IO口的高八个IO口。而每个 IO 端口的位占用 CRL 的 4 个位，高两位为 CNF，低两位为MODE。住几个常用的配置，比如 0X0 表示模拟输入模式（ADC 用）、0X3 表示推挽输出模式（做输出口用，50M 速率）、0X8 表示上/下拉输入模式（做输入口用）、0XB 表示复用输出（使用 IO 口的第二功能，50M 速率）</p><h2 id="2-GPIO相关函数"><a href="#2-GPIO相关函数" class="headerlink" title="2.GPIO相关函数"></a>2.GPIO相关函数</h2><p>   GPIO 相关的函数和定义分布在固件库文件 stm32f10x_gpio.c 和头文件 stm32f10x_gpio.h 文</p><p>件中。在固件库开发中，操作寄存器 CRH 和 CRL 来配置 IO 口的模式和速度是通过 GPIO 初始化函数完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>；</span></span><br></pre></td></tr></table></figure><p>函数的两个参数，第一个参数指定是哪一个GPIO（A~G），第二个参数为初始化结构体指针。（查找结构体的定义：到 FWLib 组下面的 stm32f10x_gpio.c文件，定位到 GPIO_Init 函数体处，双击入口参数类型 GPIO_InitTypeDef 后右键选择“Go to definition of …”）</p><p>结构体初始化GPIO的常用格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//LED0--&gt;PB.5 端口配置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//速度 50MHz</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//根据设定参数配置 GPIO</span></span><br></pre></td></tr></table></figure><p>可以看出具体哪一种模式是通过枚举类型(结构体)定义的，这里只列举其中一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> GPIO_Mode_AIN = <span class="number">0x0</span>, <span class="comment">//模拟输入</span></span><br><span class="line"> GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>, <span class="comment">//浮空输入</span></span><br><span class="line"> GPIO_Mode_IPD = <span class="number">0x28</span>, <span class="comment">//下拉输入</span></span><br><span class="line"> GPIO_Mode_IPU = <span class="number">0x48</span>, <span class="comment">//上拉输入</span></span><br><span class="line"> GPIO_Mode_Out_OD = <span class="number">0x14</span>, <span class="comment">//开漏输出</span></span><br><span class="line"> GPIO_Mode_Out_PP = <span class="number">0x10</span>, <span class="comment">//通用推挽输出</span></span><br><span class="line"> GPIO_Mode_AF_OD = <span class="number">0x1C</span>, <span class="comment">//复用开漏输出</span></span><br><span class="line"> GPIO_Mode_AF_PP = <span class="number">0x18</span> <span class="comment">//复用推挽</span></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure><h2 id="3-四个寄存器：IDR-ODR-BSRR-BRR"><a href="#3-四个寄存器：IDR-ODR-BSRR-BRR" class="headerlink" title="3.四个寄存器：IDR,ODR,BSRR,BRR"></a>3.四个寄存器：IDR,ODR,BSRR,BRR</h2><p><strong>IDR</strong>是一个端口输入数据寄存器，只用了低 16 位。该寄存器为只读寄存器，并且只能以16 位的形式读出，如图：</p><p><img src="/.io//images%5CIDR.png" alt="IDR"></p><p>如果想知道某个IO口的电平状态，只需要调用这个寄存器即可。</p><p>在固件库中操作 IDR 寄存器读取 IO 端口数据是通过 GPIO_ReadInputDataBit 函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br></pre></td></tr></table></figure><p>该函数的返回值是0或者1。</p><p><strong>ODR</strong>是一个端口输出数据寄存器，也只用了低 16 位。该寄存器为可读写，从该寄存器读出来的数据可以用于判断当前 IO 口的输出状态。而向该寄存器写数据，则可以控制某个 IO 口的输出电平。如图：</p><p><img src="/.io//images%5CODR.png" alt="ODR"></p><p>在固件库中设置 ODR 寄存器的值来控制 IO 口的输出状态是通过函数 GPIO_Write 来实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> PortVal)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数可以一次性往一个GPIO的多个端口设值。</p><p><strong>BSRR</strong>寄存器是端口位设置/清除寄存器。该寄存器和 ODR 寄存器具有类似的作用，都可以用来设置 GPIO 端口的输出位是 1 还是 0。如图：</p><p><img src="/.io//images%5CBSRR.png" alt="BSRR"></p><p>可以看出，要设置有一组IO口的某一个端口的值，写1的时候只需要操作0<del>15位（Set），写0的时候只需要操作16</del>31位（Reset）。（设置某些位的时候可以不用管其他位）。</p><p>例如你要设置 GPIOA 的第 1 个端口值为 1，那么你只需要往寄存器 BSRR 的低 16 位对应位写 1 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;BSRR=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果你要设置 GPIOA 的第 1 个端口值为 0，你只需要往寄存器高 16 位对应为写 1 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOA-&gt;BSRR=<span class="number">1</span>&lt;&lt;(<span class="number">16</span>+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>BRR</strong> 寄存器是端口位清除寄存器。该寄存器的作用跟 BSRR 的高 16 位雷同</p><p>在 STM32 固件库中，通过 BSRR 和 BRR 寄存器设置 GPIO 端口输出是通过函数GPIO_SetBits()和函数 GPIO_ResetBits()来完成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br></pre></td></tr></table></figure><p>多数情况下都是采用这两个函数来操作IO口的输入输出状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 IO口简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的基本概念</title>
      <link href="2021/05/30/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>2021/05/30/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h3><p>在ANSI C的任何一种实现中，存在两种不同的环境：翻译环境，执行环境。<br>翻译环境：源代码被转换为可执行的机器指令。执行环境：用于实际执行代码。这两种环境不必位于同一台机器上。</p><h4 id="1-1-翻译"><a href="#1-1-翻译" class="headerlink" title="1.1 翻译"></a>1.1 翻译</h4><p>翻译：组成程序的源文件（一个或者多个）通过编译转换为<strong>目标代码</strong>，然后各个目标文件由<strong>链接器</strong>捆绑在一起，形成单一而完整的可执行程序。连接器同时会引入标准C函数库中任何被该程序所用到的函数，而且它也可以搜索程序员个人的程序库，将其中需要使用的函数也链接带程序中。<br>如图：</p><p><img src="images/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt="编译过程"></p><p>一.文件名约定<br>大多数环境都存在必须遵守的文件名约定。C源代码通常保存于以.c扩展名的文件中，头文件则为.h。目标文件名在不同环境可能有不同的约定：UNIX系统中扩展名为.o，在MS-DOS系统中扩展名为.obj。<br>二.编译和链接</p><p>用于编译和链接C程序的特定命令在不同的系统中各不相同</p><p>在绝大多数的UNIX系统中，C编译器被称为cc，它可以用不同的方法来调用；</p><ol><li><p>编译并链接一个完全包含于一个源文件的C程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc program.c</span><br></pre></td></tr></table></figure><p>命令执行完之后会产生一个a.out的可执行文件（中间会产生一个名为program.o的目标文件，但是在链接过程完成后会被删除）</p></li><li><p>编译并链接几个C源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc main.c sort.c lookup.c</span><br></pre></td></tr></table></figure></li><li><p>编译一个C源文件，并把它和现存的目标文件链接在一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc main.o lookup.o sort.c</span><br></pre></td></tr></table></figure></li><li><p>编译单个C源文件，并产生一个目标文件，以后再进行链接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -c program.c</span><br></pre></td></tr></table></figure></li><li><p>编译几个C源文件，并为每个文件产生一个目标文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -c main.v sort.c lookup.c</span><br></pre></td></tr></table></figure></li><li><p>链接一个目标文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc main.o sort.o lookup.o</span><br></pre></td></tr></table></figure></li></ol><p>在产生可执行文件的命令均可以加上</p><p>​    “-o name” :  使编译器把可执行程序保存在“name”文件里</p><h4 id="1-2执行"><a href="#1-2执行" class="headerlink" title="1.2执行"></a>1.2执行</h4><p>程序的执行也需要经历几个阶段：</p><ol><li>程序载入到内存中（在宿主环境中，由操作系统执行；独立环境中需要手工安排）</li><li>在操作系统中，通常一个小型的<strong>启动程序</strong>与程序链接在一起，调用main函数（它负责处理一系列日常事务，如：收集命名行参数以便程序访问）</li><li>执行程序代码。（在绝大多数的机器里，程序将使用一个运行时<strong>堆栈</strong>，它用于存储函数的局部变量和返回地址。程序同时也可以使用<strong>静态内存</strong>，存储于静态内存中的变量在程序的整个执行过程中将一直保留它们的值。）</li><li>程序的终止。终止有如下情况：main函数返回；启动程序关闭可能使用过但并未显示关闭的文件；用户按下break键；执行过程中出现错误而中断。</li></ol><h3 id="2-词法规则"><a href="#2-词法规则" class="headerlink" title="2.词法规则"></a>2.词法规则</h3><p>一个ANSI C程序由声明和函数组成。函数定义了需要执行的工作，而声明则描述了函数和函数将要操作的数据类型，注释可以散布于源文件的各个地方。</p><h4 id="2-1-字符"><a href="#2-1-字符" class="headerlink" title="2.1 字符"></a>2.1 字符</h4><p>规定字符集必须包括英语所以的大写和小写字母，数字0到9，以及下面这些符号：</p><p><img src="images/%E5%AD%97%E7%AC%A6.png" alt="字符"></p><p>换行符用于标志源代码每一行的结束，也用于标志每个输入行的末尾，也可以是一串字符（被作为单个字符处理）</p><p><strong>三字母词</strong>：几个字符的序列合起来表示另一个字符。（可在缺少一些必需字符的字符集上实现）</p><p><img src="images/%E4%B8%89%E5%AD%97%E6%AF%8D%E8%AF%8D.png" alt="三字母词"></p><p>两个问号开头再尾随一个字符一般不会出现在其他表达形式中，所以把三字母词用这种形式来表示，这样就不致引起误解。</p><p><img src="images/%E8%AD%A6%E5%91%8A.png" alt="警告"></p><p><strong>转义序列</strong>或<strong>字符转义</strong>：解决无法再字符串常量内部包含某些字符的问题。</p><p>? 在书写连续多个问号时使用，防止它们被解释为三字母词；</p><p>\“ 用于表示一个字符串常量内部的双引号；</p><p>\‘ 用于表示字符串常量 ’；</p><p>\\ 用于表示一个反斜杠，防止它被解释为一个转义序列符。</p><p>转义符列举：</p><p><img src="images/%E8%BD%AC%E4%B9%89%E7%AC%A6.png" alt="转义符"></p><h4 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h4><p>C语言的注释以字符/*开始，以字符 */结束。</p><p>一个注释可以跨多行但是不能嵌套。注释会被预处理器拿掉，取而代之的是一个空格。</p><h4 id="2-3-标识符"><a href="#2-3-标识符" class="headerlink" title="2.3 标识符"></a>2.3 标识符</h4><p>标识符就是变量，函数，类型等的名字。它们由大小写字母，数字和下划线组成，但不能以数字开头，同时对大小写敏感，无长度限制（但标准允许编译器忽略第31个字符以后的字符）。</p><p>C语言<strong>关键字</strong>是被保留的，不能作为标识符使用：</p><p><img src="images/%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="关键字"></p><h4 id="2-5-程序的形式"><a href="#2-5-程序的形式" class="headerlink" title="2.5 程序的形式"></a>2.5 程序的形式</h4><p>一个C程序可能保存于一个或多个源文件中，每个函数都必须完整地出现于同一个源文件中。</p><h3 id="3-程序风格"><a href="#3-程序风格" class="headerlink" title="3.程序风格"></a>3.程序风格</h3><p>不良的风格和不良的文档是软件生产和维护代价高昂的两个重要原因。良好的编程风格能够大大提高程序的可读性，直接结果就是程序更容易正确运行，间接结果是它们更容易维护，这将节省大笔资金成本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言的加深--《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/27/hello-world/"/>
      <url>2021/05/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
